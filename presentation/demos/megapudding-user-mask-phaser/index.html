<!DOCTYPE html>
<html>
  <head>
    <title>Megapudding</title>
    <style>
    * {
      margin: 0;
      padding: 0;
      border: 0;
      font-family: "Helvetica Neue", Helvetica, Arial, sans-serif;
    }
    </style>
  </head>
  <body>
    <div id="game"></div>
    <script src="js/phaser/phaser.min.js"></script>
    <script>
    (function(){
      var Kinect2 = require('kinect2');
      var kinect = new Kinect2();

      var game, bmd, hiddenCanvas, hiddenRenderer, activeBody;

      function init() {
        game = new Phaser.Game(window.innerWidth, window.innerHeight, Phaser.AUTO, 'game', { preload: preload, create: create, update: update });

        hiddenCanvas = document.createElement('canvas');
        hiddenCanvas.setAttribute('width', 1920);
        hiddenCanvas.setAttribute('height', 1080);
        hiddenRenderer = new ColorRenderer(hiddenCanvas);
         if(kinect.open()) {
          console.log('kinect open');
          kinect.on('multiSourceFrame', multiSourceFrameHandler);
          kinect.openMultiSourceReader({
            frameTypes: Kinect2.FrameType.bodyIndexColor | Kinect2.FrameType.body,
            includeJointFloorData: true
          });
        }
      }

      function preload() {
      }

      function create() {
        console.log('create');
        bmd = game.add.bitmapData(game.width, game.height);
        bmd.addToWorld(bmd.width * 0.5, bmd.height, 0.5, 1);
      }

      function update() {
      }

      function multiSourceFrameHandler(frame) {
        var closestBody = getClosestBody(frame.body);
        if(closestBody && closestBody !== activeBody) {
          activeBody = closestBody;
          kinect.trackPixelsForBodyIndices([activeBody.bodyIndex]);
        }
        if(activeBody && frame.bodyIndexColor.bodies[activeBody.bodyIndex].buffer) {
          hiddenRenderer.update(frame.bodyIndexColor.bodies[activeBody.bodyIndex].buffer);

          var pixelWidth = calculatePixelWidth(frame.bodyIndexColor.horizontalFieldOfView, activeBody.joints[Kinect2.JointType.spineMid].cameraZ * 1000);
          var scale = 0.15 * pixelWidth;

          var leftJoint = activeBody.joints[0],
            topJoint = activeBody.joints[0],
            rightJoint = activeBody.joints[0];
          activeBody.joints.forEach(function(joint){
            if(joint.colorX < leftJoint.colorX) {
              leftJoint = joint;
            }
            if(joint.colorX > rightJoint.colorX) {
              rightJoint = joint;
            }
            if(joint.colorY < topJoint.colorY) {
              topJoint = joint;
            }
          });
          //head joint is in middle of head, add area (y-distance from neck to head joint) above
          topJoint = {
            colorX: topJoint.colorX,
            colorY: Math.min(topJoint.colorY, activeBody.joints[Kinect2.JointType.head].colorY - (activeBody.joints[Kinect2.JointType.neck].colorY - activeBody.joints[Kinect2.JointType.head].colorY))
          };
          var srcRect = {
            x: leftJoint.colorX * hiddenCanvas.width,
            y: topJoint.colorY * hiddenCanvas.height,
            width: (rightJoint.colorX - leftJoint.colorX) * hiddenCanvas.width,
            height: (activeBody.joints[Kinect2.JointType.spineMid].floorColorY - topJoint.colorY) * hiddenCanvas.height
          };
          var dstRect = {
            x: bmd.width * 0.5,
            y: bmd.height - (srcRect.height * scale),
            width: srcRect.width * scale,
            height: srcRect.height * scale
          };

          //center the user horizontally - is not minus half width of image as user might reach to one side or the other
          //do minus the space on the left size of the spine
          var spaceLeft = activeBody.joints[Kinect2.JointType.spineMid].colorX - leftJoint.colorX;
          dstRect.x -= (spaceLeft * hiddenCanvas.width * scale);
          if(bmd) {
            bmd.cls();
            bmd.copy(hiddenCanvas, srcRect.x, srcRect.y, srcRect.width, srcRect.height, dstRect.x, dstRect.y, dstRect.width, dstRect.height);
          }
        }
      }

      function calculatePixelWidth(horizontalFieldOfView, depth){
        // measure the size of the pixel
        var hFov = horizontalFieldOfView / 2;
        var numPixels = hiddenCanvas.width / 2;
        var T = Math.tan((Math.PI * 180) / hFov);
        var pixelWidth = T * depth;
        return pixelWidth / numPixels;
      }

      function getClosestBody(bodyFrame) {
        var closestZ = Number.MAX_VALUE;
        var closestBody = false;
        bodyFrame.bodies.forEach(function(body){
          if(body.tracked && body.joints[Kinect2.JointType.spineMid].cameraZ < closestZ) {
            closestZ = body.joints[Kinect2.JointType.spineMid.cameraZ];
            closestBody = body;
          }
        });
        return closestBody;
      }

      function ColorRenderer(outputCanvas) {
        this.canvas = outputCanvas;
        this.ctx = this.canvas.getContext('2d');
        this.imageData = this.ctx.createImageData(this.canvas.width, this.canvas.height);
        this.imageDataSize = this.imageData.data.length;
        this.imageDataArray = this.imageData.data;

        this.update = function(newPixelData) {
          for (var i = 0; i < this.imageDataSize; i++) {
            this.imageDataArray[i] = newPixelData[i];
          }
          this.ctx.putImageData(this.imageData, 0, 0);
        }
      }

      init();
    })();
    </script>
  </body>
</html>
